<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MS Rewards Tracker</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .header-fixed {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            z-index: 100;
            margin-bottom: 22px;
        }

        h1 {
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
            font-weight: 100;
            color: #7d7b19;
            margin-bottom: 15px;
            font-size: 28px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .table-wrapper {
            overflow-x: auto;
            width: 100%;
        }

        .month-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .month-selector button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Roboto Black', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
            font-weight: 900;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .month-selector button .material-icons {
            font-size: 22px;
        }

        .month-selector button:hover {
            background: #005a9e;
        }

        .month-selector span {
            font-size: 12px;
            text-align: center;
        }
        

        .action-buttons button {
            font-family: 'Roboto Black', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
            font-weight: 900;                
            background: #107c10;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .action-buttons button .material-icons {
            font-size: 22px;
        }

        .action-buttons span{
            font-size: 12px;
            text-align: center;          
        }

        .action-buttons button:hover {
            background: #0d5f0d;
        }

        .action-buttons button.clear {
            background: #d13438;
        }

        .action-buttons button.clear:hover {
            background: #a72828;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            background: white;
        }

        th, td {
            border: 1px solid #d0d0d0;
            border-top: 0px;
            padding: 6px;
            text-align: center;
            min-width: 60px;
        }

        th {
            background: #4472c4;
            color: white;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .row-header {
            background: #cacaca;
            font-size: 9pt;
            color: black;
            font-weight: bold;
            text-align: end;
            padding-right: 15px;
            min-width: 150px;
            position: sticky;
            left: 0;
            z-index: 15;
            border-width: 0px;
            height: 40px;
        }

        .row-header.sub {
            background: #70ad47;
        }

        .row-header.yellow {
            background: #ffc000;
            color: black;
        }

        .row-header.red {
            background: #c00000;
        }

        .row-header.green {
            background: #70ad47;
        }

        .row-header.orange {
            background: #ed7d31;
        }

        .row-header.purple {
            background: #7030a0;
        }

        input[type="number"], select {
            font-family: 'Roboto Light', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12pt;
            font-weight: 300;
            border: none;
            text-align: center;
            padding: 2px;
            background: transparent;
        }

        input[type="number"]:focus, select:focus {
            outline: 2px solid #0078d4;
            background: #fff4ce;
        }

        select {
            font-family: 'Roboto Light', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12pt;
            font-weight: 300;
            cursor: pointer;            
        }

        .editable {
            background: #ffffff;
            cursor: pointer;
        }

        .editable:hover {
            background: #f0f0f0;
        }

        .points-row {
            font-family: 'Roboto SemiBold', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            font-weight: 100;
            background: #e7e6e6;
            position: relative;
            z-index: 1;
        }

        .total-cell {
            background: #70ad47;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .date-header {
            background: #000000;
            color: white;
            font-size: 11px;
            border-color: #000000;
        }

        .bonus-cell {
            background: #ffc000;
            font-weight: bold;
            padding: 2px;
            font-size: 10px;
        }

        .bonus-text {
            font-size: 12px;
            word-wrap: break-word;
        }

        .special-bonus {
            background: #ff6b6b;
            color: white;
        }

        .group-border-right {
            border-right: 3px solid #000000 !important;
        }

        .group-border-left {
            border-left: 3px solid #000000 !important;
        }

        .group-border-top {
            border-top: 3px solid #000000 !important;
        }

        .group-border-bottom {
            border-bottom: 3px solid #000000 !important;
        }

        /* Remove bordas verticais internas dentro dos grupos */
        .group-inside-left {
            border-left: 0 !important;
        }

        .group-inside-right {
            border-right: 0 !important;
        }

        /* Background para células dentro dos grupos */
        .group-background {
            background: #FFF2CC !important;
        }

        .group-background:hover {
            background: #FFE699 !important;
        }

        /* Background para células vazias dessas atividades específicas */
        .group-empty-background {
            background: #FFF9EF !important;
        }

        .group-empty-background:hover {
            background: #FFF2CC !important;
        }

        /* Background para Diaria do App Bing e Noticias do App Bing */
        .bing-app-empty {
            background: #E8EDF7 !important;
        }

        .bing-app-empty:hover {
            background: #D9E1F2 !important;
        }

        .bing-app-filled {
            background: #D9E1F2 !important;
        }

        .bing-app-filled:hover {
            background: #C5D0E8 !important;
        }

        /* Background para Use o App Xbox e Jogar Jewels */
        .green-app-empty {
            background: #E2EFDA !important;
        }

        .green-app-empty:hover {
            background: #C6E0B4 !important;
        }

        .green-app-filled {
            background: #C6E0B4 !important;
        }

        .green-app-filled:hover {
            background: #A9D08E !important;
        }

        .game-app-empty {
            background: #DCECD1 !important;
        }

        .game-app-empty:hover {
            background: #C6E0B4 !important;
        }

        .game-app-filled {
            background: #C6E0B4 !important;
        }

        .game-app-filled:hover {
            background: #A9D08E !important;
        }

        /* Tooltip para células de bônus */
        .bonus-cell-wrapper {
            position: relative;
            cursor: pointer;
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12pt;
            font-weight: 500;
        }

        .bonus-tooltip {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 11px;
            line-height: 1.5;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .bonus-tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .bonus-cell-wrapper:hover .bonus-tooltip {
            visibility: visible;
        }

        /* Modal popup para adicionar pontuação extra */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-content h2 {
            margin-top: 0;
            color: #0078d4;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-content label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .modal-content input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .modal-content input:focus {
            outline: 2px solid #0078d4;
            border-color: #0078d4;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px;
        }

        .modal-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            font-weight: bold;
        }

        .modal-buttons .btn-ok {
            background: #107c10;
            color: white;
        }

        .modal-buttons .btn-ok:hover {
            background: #0d5f0d;
        }

        .modal-buttons .btn-cancel {
            background: #d13438;
            color: white;
        }

        .modal-buttons .btn-cancel:hover {
            background: #a72828;
        }

        /* Classe para textos dos botões */
        .button-text {
            display: inline;
        }

        /* Media query para telas menores - ocultar textos dos botões */
        @media screen and (max-width: 940px) {
            .button-text {
                display: none;
            }
            
            .month-selector button,
            .action-buttons button {
                min-width: 40px;
                padding: 8px;
                gap: 0;
            }
            
            .month-selector {
                gap: 5px;
            }
        }

        @media print {
            .controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-fixed">
            <h1><span class="material-icons">diamond</span> Microsoft Rewards Tracker</h1>
            
            <div class="controls">
                <div class="month-selector">
                    <button onclick="previousMonth()" style="width: 40px;"><span class="material-icons">arrow_back</span></button>
                    <span id="currentMonth" style="width: 75px; font-size: 14px; font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;"></span>
                    <button onclick="nextMonth()" style="width: 40px;"><span class="material-icons">arrow_forward</span></button>
                    <button onclick="openAddBonusModal()" style="background: #0078d4;">
                        <span class="material-icons">calendar_month</span><span class="button-text"> Adicionar</span>
                    </button>
                    <button onclick="openSaqueModal()" style="background: #c00000;">
                        <span class="material-icons">outbox</span><span class="button-text">  Saque</span>
                    </button>
                </div>
                <div class="action-buttons">
                    <button onclick="saveData()">
                        <span class="material-icons">save</span><span class="button-text"> Salvar</span>
                    </button>
                    <button onclick="exportData()">
                        <span class="material-icons">save_alt</span><span class="button-text"> Exportar</span>
                    </button>
                    <button onclick="document.getElementById('importFileInput').click()">
                        <span class="material-icons">file_upload</span><span class="button-text"> Importar</span>
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="importData(event)">
                    <button class="clear" onclick="clearMonth()">
                        <span class="material-icons">clear</span><span class="button-text"> Limpar Mês</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="table-wrapper">
            <div id="tableContainer"></div>
        </div>
    </div>

    <!-- Modal para adicionar pontuação extra -->
    <div id="addBonusModal" class="modal">
        <div class="modal-content">
            <h2><span class="material-icons">calendar_month</span> Adicionar Pontuação Extra</h2>
            <label for="bonusTitle">Título da Pontuação:</label>
            <input type="text" id="bonusTitle" placeholder="Ex: Bonus Especial" />
            
            <label for="bonusPoints">Quantidade de Pontos:</label>
            <input type="number" id="bonusPoints" placeholder="Ex: 100" min="0" />
            
            <label for="bonusDate">Data (Dia do mês atual):</label>
            <input type="number" id="bonusDate" placeholder="Ex: 15" min="1" max="31" />
            
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeAddBonusModal()">Cancelar</button>
                <button class="btn-ok" onclick="addExtraBonus()">OK</button>
            </div>
        </div>
    </div>

    <!-- Modal para Saque -->
    <div id="saqueModal" class="modal">
        <div class="modal-content">
            <h2><span class="material-icons">outbox</span> Registrar Saque</h2>
            <label for="saqueTitle">Título do Saque:</label>
            <input type="text" id="saqueTitle" placeholder="Ex: Resgate Gift Card" />
            
            <label for="saquePoints">Quantidade de Pontos:</label>
            <input type="number" id="saquePoints" placeholder="Ex: 5000" min="0" />
            
            <label for="saqueDate">Data (Dia do mês atual):</label>
            <input type="number" id="saqueDate" placeholder="Ex: 15" min="1" max="31" />
            
            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeSaqueModal()">Cancelar</button>
                <button class="btn-ok" onclick="addSaque()">OK</button>
            </div>
        </div>
    </div>

    <script>
        // Estrutura de dados
        const today = new Date();
        let currentYear = today.getFullYear();
        let currentMonth = today.getMonth(); // 0-indexed (0 = Janeiro, 11 = Dezembro)
        let data = {};

        const monthNames = ['Jan.', 'Fev.', 'Mar.', 'Abr.', 'Mai.', 'Jun.', 
                           'Jul.', 'Ago.', 'Set.', 'Out.', 'Nov.', 'Dez.'];

        const activities = [
            { id: 'conjuntodiario', name: 'Conjunto Diario', color: '#FFFF00', defaultValue: 125 },
            { id: 'maisatividade', name: 'Mais Atividade', color: '#FFFF00', defaultValue: 300 },
            { id: 'pesquisabingpc', name: 'Pesquisas do Bing', color: '#FFFF00', defaultValue: 30 },
            { id: 'diariabing', name: 'Diaria do App Bing', color: '#5a8eed', defaultValue: 25 },
            { id: 'noticiasbing', name: 'Noticias do App Bing', color: '#5a8eed', defaultValue: 150 },
            { id: 'useappxbox', name: 'Use o App Xbox no Celular', color: '#00B050', defaultValue: 5 },
            { id: 'playjewels', name: 'Jogar Jewels no Celular', color: '#00B050', defaultValue: 5 },
            { id: 'playgamepass', name: 'Jogar um jogo do Gamepass', color: '#92D050', defaultValue: 20 },
            { id: 'playconsole', name: 'Jogar um jogo no Xbox', color: '#92D050', defaultValue: 20 },
            { id: 'playwindows', name: 'Jogar um jogo no PC', color: '#92D050', defaultValue: 5 }
        ];

        // ===== CONFIGURAÇÕES DE BÔNUS =====
        // Altere os valores abaixo para modificar os bônus concedidos
        const BONUS_CONFIG = {
            // Quebra Cabeças Bing - 7 dias consecutivos de Pesquisas Bing PC
            quebraCabecasBing: {
                valor: 100,
                nome: 'Quebra Cabeças Bing',
                diasConsecutivos: 7,
                atividade: 'pesquisabingpc'
            },
            // Bônus de Sequência do Bing - 10 dias consecutivos de Conjunto Diário
            bonusSequenciaBing: {
                valor: 150,
                nome: 'Bonus de Sequencia do Bing',
                diasConsecutivos: 10,
                atividade: 'conjuntodiario'
            },
            // Sequências Semanais Gamepass - 7 dias consecutivos de Jogar Gamepass
            sequenciasSemanaisGamepass: {
                valor: 700,
                nome: 'Sequencias Semanais Gamepass',
                diasConsecutivos: 7,
                atividade: 'playgamepass'
            },
            // Bônus Semanal do Console - 5 dias em uma semana de Jogar Xbox
            bonusSemanalConsole: {
                valor: 260,
                nome: 'Bonus Semanal do Console',
                diasPorSemana: 5,
                atividade: 'playconsole'
            },
            // Bônus Semanal do Windows - 5 dias em uma semana de Jogar PC
            bonusSemanalWindows: {
                valor: 260,
                nome: 'Bonus Semanal do Windows',
                diasPorSemana: 5,
                atividade: 'playwindows'
            }
        };

        // Inicialização
        function init() {
            loadData();
            updateMonthDisplay();
            generateTable();
        }

        function updateMonthDisplay() {
            document.getElementById('currentMonth').textContent = 
                `${monthNames[currentMonth]} ${currentYear}`;
        }

        function getDaysInMonth(year, month) {
            return new Date(year, month + 1, 0).getDate();
        }

        function getDayOfWeek(year, month, day) {
            const date = new Date(year, month, day);
            return date.getDay(); // 0 = Domingo, 6 = Sábado
        }

        function isWeekend(year, month, day) {
            const date = new Date(year, month, day);
            const dayOfWeek = date.getDay();
            return dayOfWeek === 0 || dayOfWeek === 6;
        }

        function generateTable() {
            const daysInMonth = getDaysInMonth(currentYear, currentMonth);
            const monthKey = `${currentYear}-${currentMonth}`;
            
            if (!data[monthKey]) {
                data[monthKey] = {};
            }

            let html = '<table><thead><tr><th class="row-header">Dia da semana</th>';
            
            // Cabeçalho com dias
            for (let day = 1; day <= daysInMonth; day++) {
                html += `<th class="date-header">${day}</th>`;
            }
            html += '</tr></thead><tbody>';

            // CALCULAR BÔNUS ANTES DAS LINHAS DE ACUMULADO/TOTAL
            // Detectar grupos de 7 dias completados de pesquisabingpc para bônus
            // Estrutura: bonusPerDay[day] = { total: number, items: [{value: number, name: string}] }
            let bonusPerDay = {};
            
            // === BÔNUS 1: Quebra Cabeças Bing (7 dias de Pesquisas Bing PC) ===
            // Identificar todos os grupos de 7 dias consecutivos de pesquisabingpc
            let consecutiveDays = 0;
            let groupStart = 0;
            
            // Verificar se há continuação do mês anterior
            const prevMonthForBonus = currentMonth - 1;
            const prevYearForBonus = prevMonthForBonus < 0 ? currentYear - 1 : currentYear;
            const prevMonthIndexForBonus = prevMonthForBonus < 0 ? 11 : prevMonthForBonus;
            const prevMonthKeyForBonus = `${prevYearForBonus}-${prevMonthIndexForBonus}`;
            const prevMonthDaysForBonus = getDaysInMonth(prevYearForBonus, prevMonthIndexForBonus);
            
            // Contar dias consecutivos do final do mês anterior
            for (let d = prevMonthDaysForBonus; d >= 1; d--) {
                const dKey = `day${d}`;
                const dValue = data[prevMonthKeyForBonus]?.[dKey]?.pesquisabingpc;
                if (dValue && dValue !== '' && dValue !== 0) {
                    consecutiveDays++;
                } else {
                    break;
                }
            }
            
            // Se já havia dias consecutivos do mês anterior, ajustar
            if (consecutiveDays > 0) {
                consecutiveDays = Math.min(consecutiveDays, 6); // Máximo 6 do mês anterior
            }
            
            // Processar dias do mês atual para detectar bônus
            for (let d = 1; d <= daysInMonth; d++) {
                const dKey = `day${d}`;
                const dValue = data[monthKey][dKey]?.pesquisabingpc;
                
                if (dValue && dValue !== '' && dValue !== 0) {
                    if (consecutiveDays === 0) {
                        groupStart = d;
                    }
                    consecutiveDays++;
                    
                    // Se completou 7 dias, adicionar bônus no 7º dia
                    if (consecutiveDays === 7) {
                        if (!bonusPerDay[d]) {
                            bonusPerDay[d] = { total: 0, items: [] };
                        }
                        bonusPerDay[d].total += BONUS_CONFIG.quebraCabecasBing.valor;
                        bonusPerDay[d].items.push({ value: BONUS_CONFIG.quebraCabecasBing.valor, name: BONUS_CONFIG.quebraCabecasBing.nome });
                        consecutiveDays = 0; // Resetar para o próximo grupo
                        groupStart = 0;
                    }
                } else {
                    // Dia vazio ou sem pontos, resetar contador
                    consecutiveDays = 0;
                    groupStart = 0;
                }
            }

            // === BÔNUS 2: Bonus de Sequencia do Bing (10 dias de Conjunto Diario) ===
            let consecutiveDaysConjunto = 0;
            let groupStartConjunto = 0;
            
            // Contar dias consecutivos do final do mês anterior
            for (let d = prevMonthDaysForBonus; d >= 1; d--) {
                const dKey = `day${d}`;
                const dValue = data[prevMonthKeyForBonus]?.[dKey]?.conjuntodiario;
                if (dValue && dValue !== '' && dValue !== 0) {
                    consecutiveDaysConjunto++;
                } else {
                    break;
                }
            }
            
            // Se já havia dias consecutivos do mês anterior, ajustar
            if (consecutiveDaysConjunto > 0) {
                consecutiveDaysConjunto = Math.min(consecutiveDaysConjunto, 9); // Máximo 9 do mês anterior
            }
            
            // Processar dias do mês atual para detectar bônus de Conjunto Diario
            for (let d = 1; d <= daysInMonth; d++) {
                const dKey = `day${d}`;
                const dValue = data[monthKey][dKey]?.conjuntodiario;
                
                if (dValue && dValue !== '' && dValue !== 0) {
                    if (consecutiveDaysConjunto === 0) {
                        groupStartConjunto = d;
                    }
                    consecutiveDaysConjunto++;
                    
                    // Se completou 10 dias, adicionar bônus no 10º dia
                    if (consecutiveDaysConjunto === 10) {
                        if (!bonusPerDay[d]) {
                            bonusPerDay[d] = { total: 0, items: [] };
                        }
                        bonusPerDay[d].total += BONUS_CONFIG.bonusSequenciaBing.valor;
                        bonusPerDay[d].items.push({ value: BONUS_CONFIG.bonusSequenciaBing.valor, name: BONUS_CONFIG.bonusSequenciaBing.nome });
                        consecutiveDaysConjunto = 0; // Resetar para o próximo grupo
                        groupStartConjunto = 0;
                    }
                } else {
                    // Dia vazio ou sem pontos, resetar contador
                    consecutiveDaysConjunto = 0;
                    groupStartConjunto = 0;
                }
            }

            // === BÔNUS 3: Sequencias Semanais Gamepass (7 dias de Jogar um jogo pelo Gamepass) ===
            let consecutiveDaysGamepass = 0;
            let groupStartGamepass = 0;
            
            // Contar dias consecutivos do final do mês anterior
            for (let d = prevMonthDaysForBonus; d >= 1; d--) {
                const dKey = `day${d}`;
                const dValue = data[prevMonthKeyForBonus]?.[dKey]?.playgamepass;
                if (dValue && dValue !== '' && dValue !== 0) {
                    consecutiveDaysGamepass++;
                } else {
                    break;
                }
            }
            
            // Se já havia dias consecutivos do mês anterior, ajustar
            if (consecutiveDaysGamepass > 0) {
                consecutiveDaysGamepass = Math.min(consecutiveDaysGamepass, 6); // Máximo 6 do mês anterior
            }
            
            // Processar dias do mês atual para detectar bônus de Gamepass
            for (let d = 1; d <= daysInMonth; d++) {
                const dKey = `day${d}`;
                const dValue = data[monthKey][dKey]?.playgamepass;
                
                if (dValue && dValue !== '' && dValue !== 0) {
                    if (consecutiveDaysGamepass === 0) {
                        groupStartGamepass = d;
                    }
                    consecutiveDaysGamepass++;
                    
                    // Se completou 7 dias, adicionar bônus no 7º dia
                    if (consecutiveDaysGamepass === 7) {
                        if (!bonusPerDay[d]) {
                            bonusPerDay[d] = { total: 0, items: [] };
                        }
                        bonusPerDay[d].total += BONUS_CONFIG.sequenciasSemanaisGamepass.valor;
                        bonusPerDay[d].items.push({ value: BONUS_CONFIG.sequenciasSemanaisGamepass.valor, name: BONUS_CONFIG.sequenciasSemanaisGamepass.nome });
                        consecutiveDaysGamepass = 0; // Resetar para o próximo grupo
                        groupStartGamepass = 0;
                    }
                } else {
                    // Dia vazio ou sem pontos, resetar contador
                    consecutiveDaysGamepass = 0;
                    groupStartGamepass = 0;
                }
            }

            // === BÔNUS 4: Bonus Semanal do PC (5 dias de Console em uma semana) ===
            // Verificar se há uma semana do mês anterior que continua neste mês
            const prevMonthConsole = currentMonth - 1;
            const prevYearConsole = prevMonthConsole < 0 ? currentYear - 1 : currentYear;
            const prevMonthIndexConsole = prevMonthConsole < 0 ? 11 : prevMonthConsole;
            const prevMonthKeyConsole = `${prevYearConsole}-${prevMonthIndexConsole}`;
            const prevMonthDaysConsole = getDaysInMonth(prevYearConsole, prevMonthIndexConsole);
            
            let markedDaysFromPrevMonthConsole = [];
            let countFromPrevMonthConsole = 0;
            
            // Verificar os últimos dias do mês anterior para uma semana que continua
            for (let d = prevMonthDaysConsole; d >= 1; d--) {
                const dayOfWeek = getDayOfWeek(prevYearConsole, prevMonthIndexConsole, d);
                if (dayOfWeek === 0) break; // Chegou no domingo, parar
                
                const dKey = `day${d}`;
                const dValue = data[prevMonthKeyConsole]?.[dKey]?.playconsole;
                if (dValue && dValue !== '') {
                    markedDaysFromPrevMonthConsole.unshift(d);
                    countFromPrevMonthConsole++;
                }
            }
            
            // Processar cada semana do mês atual
            for (let d = 1; d <= daysInMonth; d++) {
                const dayOfWeek = getDayOfWeek(currentYear, currentMonth, d);
                
                // Se for segunda-feira ou primeiro dia do mês, começar uma nova semana
                if (dayOfWeek === 1 || d === 1) {
                    // Encontrar o domingo dessa semana (ou último dia do mês)
                    let weekEnd = d;
                    for (let wd = d; wd <= daysInMonth; wd++) {
                        const wdDayOfWeek = getDayOfWeek(currentYear, currentMonth, wd);
                        weekEnd = wd;
                        if (wdDayOfWeek === 0) break; // Domingo
                    }
                    
                    // Contar dias marcados nesta semana
                    let markedDays = [];
                    for (let wd = d; wd <= weekEnd; wd++) {
                        const wdKey = `day${wd}`;
                        const wdValue = data[monthKey][wdKey]?.playconsole;
                        if (wdValue && wdValue !== '') {
                            markedDays.push(wd);
                        }
                    }
                    
                    // Se é a primeira semana do mês e há dias do mês anterior
                    if (d === 1 && countFromPrevMonthConsole > 0) {
                        // Combinar com dias do mês anterior
                        const totalMarked = countFromPrevMonthConsole + markedDays.length;
                        if (totalMarked >= 5) {
                            // Adicionar bônus no 5º dia marcado (considerando dias do mês anterior)
                            const remainingToFive = 5 - countFromPrevMonthConsole;
                            if (remainingToFive > 0 && markedDays.length >= remainingToFive) {
                                const fifthDayIndex = remainingToFive - 1;
                                const fifthDay = markedDays[fifthDayIndex];
                                
                                if (!bonusPerDay[fifthDay]) {
                                    bonusPerDay[fifthDay] = { total: 0, items: [] };
                                }
                                bonusPerDay[fifthDay].total += BONUS_CONFIG.bonusSemanalConsole.valor;
                                bonusPerDay[fifthDay].items.push({ value: BONUS_CONFIG.bonusSemanalConsole.valor, name: BONUS_CONFIG.bonusSemanalConsole.nome });
                            }
                        }
                    } else {
                        // Semana normal dentro do mês
                        if (markedDays.length >= 5) {
                            // Adicionar bônus no 5º dia marcado
                            const fifthDay = markedDays[4]; // índice 4 = 5º dia
                            
                            if (!bonusPerDay[fifthDay]) {
                                bonusPerDay[fifthDay] = { total: 0, items: [] };
                            }
                            bonusPerDay[fifthDay].total += BONUS_CONFIG.bonusSemanalConsole.valor;
                            bonusPerDay[fifthDay].items.push({ value: BONUS_CONFIG.bonusSemanalConsole.valor, name: BONUS_CONFIG.bonusSemanalConsole.nome });
                        }
                    }
                    
                    // Pular para o próximo dia após o domingo desta semana
                    d = weekEnd;
                }
            }

            // === BÔNUS 5: Bonus Semanal do Windows (5 dias de Windows em uma semana) ===
            // Verificar se há uma semana do mês anterior que continua neste mês
            const prevMonthWindows = currentMonth - 1;
            const prevYearWindows = prevMonthWindows < 0 ? currentYear - 1 : currentYear;
            const prevMonthIndexWindows = prevMonthWindows < 0 ? 11 : prevMonthWindows;
            const prevMonthKeyWindows = `${prevYearWindows}-${prevMonthIndexWindows}`;
            const prevMonthDaysWindows = getDaysInMonth(prevYearWindows, prevMonthIndexWindows);
            
            let markedDaysFromPrevMonthWindows = [];
            let countFromPrevMonthWindows = 0;
            
            // Verificar os últimos dias do mês anterior para uma semana que continua
            for (let d = prevMonthDaysWindows; d >= 1; d--) {
                const dayOfWeek = getDayOfWeek(prevYearWindows, prevMonthIndexWindows, d);
                if (dayOfWeek === 0) break; // Chegou no domingo, parar
                
                const dKey = `day${d}`;
                const dValue = data[prevMonthKeyWindows]?.[dKey]?.playwindows;
                if (dValue && dValue !== '') {
                    markedDaysFromPrevMonthWindows.unshift(d);
                    countFromPrevMonthWindows++;
                }
            }
            
            // Processar cada semana do mês atual
            for (let d = 1; d <= daysInMonth; d++) {
                const dayOfWeek = getDayOfWeek(currentYear, currentMonth, d);
                
                // Se for segunda-feira ou primeiro dia do mês, começar uma nova semana
                if (dayOfWeek === 1 || d === 1) {
                    // Encontrar o domingo dessa semana (ou último dia do mês)
                    let weekEnd = d;
                    for (let wd = d; wd <= daysInMonth; wd++) {
                        const wdDayOfWeek = getDayOfWeek(currentYear, currentMonth, wd);
                        weekEnd = wd;
                        if (wdDayOfWeek === 0) break; // Domingo
                    }
                    
                    // Contar dias marcados nesta semana
                    let markedDays = [];
                    for (let wd = d; wd <= weekEnd; wd++) {
                        const wdKey = `day${wd}`;
                        const wdValue = data[monthKey][wdKey]?.playwindows;
                        if (wdValue && wdValue !== '') {
                            markedDays.push(wd);
                        }
                    }
                    
                    // Se é a primeira semana do mês e há dias do mês anterior
                    if (d === 1 && countFromPrevMonthWindows > 0) {
                        // Combinar com dias do mês anterior
                        const totalMarked = countFromPrevMonthWindows + markedDays.length;
                        if (totalMarked >= 5) {
                            // Adicionar bônus no 5º dia marcado (considerando dias do mês anterior)
                            const remainingToFive = 5 - countFromPrevMonthWindows;
                            if (remainingToFive > 0 && markedDays.length >= remainingToFive) {
                                const fifthDayIndex = remainingToFive - 1;
                                const fifthDay = markedDays[fifthDayIndex];
                                
                                if (!bonusPerDay[fifthDay]) {
                                    bonusPerDay[fifthDay] = { total: 0, items: [] };
                                }
                                bonusPerDay[fifthDay].total += BONUS_CONFIG.bonusSemanalWindows.valor;
                                bonusPerDay[fifthDay].items.push({ value: BONUS_CONFIG.bonusSemanalWindows.valor, name: BONUS_CONFIG.bonusSemanalWindows.nome });
                            }
                        }
                    } else {
                        // Semana normal dentro do mês
                        if (markedDays.length >= 5) {
                            // Adicionar bônus no 5º dia marcado
                            const fifthDay = markedDays[4]; // índice 4 = 5º dia
                            
                            if (!bonusPerDay[fifthDay]) {
                                bonusPerDay[fifthDay] = { total: 0, items: [] };
                            }
                            bonusPerDay[fifthDay].total += BONUS_CONFIG.bonusSemanalWindows.valor;
                            bonusPerDay[fifthDay].items.push({ value: BONUS_CONFIG.bonusSemanalWindows.valor, name: BONUS_CONFIG.bonusSemanalWindows.nome });
                        }
                    }
                    
                    // Pular para o próximo dia após o domingo desta semana
                    d = weekEnd;
                }
            }

            // === ADICIONAR BÔNUS EXTRAS PERSONALIZADOS ===
            // Verificar se existem bônus extras salvos para este mês
            if (data[monthKey].extraBonuses) {
                for (let d = 1; d <= daysInMonth; d++) {
                    const dayKey = `day${d}`;
                    const extraBonusesForDay = data[monthKey].extraBonuses[dayKey];
                    
                    if (extraBonusesForDay && extraBonusesForDay.length > 0) {
                        if (!bonusPerDay[d]) {
                            bonusPerDay[d] = { total: 0, items: [] };
                        }
                        
                        // Adicionar cada bônus extra ao dia
                        extraBonusesForDay.forEach(extraBonus => {
                            bonusPerDay[d].total += extraBonus.points;
                            bonusPerDay[d].items.push({ 
                                value: extraBonus.points, 
                                name: extraBonus.title 
                            });
                        });
                    }
                }
            }

            // === CALCULAR SAQUES POR DIA ===
            let saquePerDay = {};
            if (data[monthKey].saques) {
                for (let day = 1; day <= daysInMonth; day++) {
                    const dayKey = `day${day}`;
                    const saquesForDay = data[monthKey].saques[dayKey];
                    
                    if (saquesForDay && saquesForDay.length > 0) {
                        let totalSaque = 0;
                        let items = [];
                        saquesForDay.forEach(saque => {
                            totalSaque += saque.points;
                            items.push({ value: saque.points, name: saque.title });
                        });
                        saquePerDay[day] = { total: totalSaque, items: items };
                    }
                }
            }

            // Linha de Acumulado (Soma acumulada até o dia, continuando de todos os meses anteriores)
            html += '<tr><td class="row-header">Acumulado</td>';
            
            // Buscar o acumulado de TODOS os meses anteriores
            let accumulated = 0;
            
            // Percorrer todos os meses desde o início até o mês anterior ao atual
            for (let year = 2024; year <= currentYear; year++) {
                const maxMonth = (year === currentYear) ? currentMonth - 1 : 11;
                for (let month = 0; month <= maxMonth; month++) {
                    const checkMonthKey = `${year}-${month}`;
                    if (data[checkMonthKey]) {
                        const monthDays = getDaysInMonth(year, month);
                        // Somar todos os dias deste mês (incluindo pontos normais e bônus extras)
                        for (let d = 1; d <= monthDays; d++) {
                            const dKey = `day${d}`;
                            const dPoints = data[checkMonthKey][dKey]?.pontos || 0;
                            accumulated += parseInt(dPoints) || 0;
                            
                            // Adicionar bônus extras deste mês anterior
                            if (data[checkMonthKey].extraBonuses && data[checkMonthKey].extraBonuses[dKey]) {
                                const extraBonuses = data[checkMonthKey].extraBonuses[dKey];
                                extraBonuses.forEach(bonus => {
                                    accumulated += parseInt(bonus.points) || 0;
                                });
                            }
                            
                            // Subtrair saques deste mês anterior
                            if (data[checkMonthKey].saques && data[checkMonthKey].saques[dKey]) {
                                const saques = data[checkMonthKey].saques[dKey];
                                saques.forEach(saque => {
                                    accumulated -= parseInt(saque.points) || 0;
                                });
                            }
                        }
                    }
                }
            }
            
            // Agora adicionar os dias do mês atual (incluindo bônus e subtraindo saques)
            for (let day = 1; day <= daysInMonth; day++) {
                const dayKey = `day${day}`;
                const dayPoints = data[monthKey][dayKey]?.pontos || 0;
                const dayBonus = bonusPerDay[day] ? bonusPerDay[day].total : 0;
                const daySaque = saquePerDay[day] ? saquePerDay[day].total : 0;
                accumulated += parseInt(dayPoints) || 0;
                accumulated += parseInt(dayBonus) || 0;
                accumulated -= parseInt(daySaque) || 0;
                html += `<td class="points-row">${accumulated}</td>`;
            }
            html += '</tr>';

            // Linha de Total Dia (Pontos do dia + bônus)
            // Calcular total de pontos do mês (pontos + bônus - saques)
            let totalPontosMes = 0;
            for (let day = 1; day <= daysInMonth; day++) {
                const dayKey = `day${day}`;
                const pointsValue = data[monthKey][dayKey]?.pontos || 0;
                const dayBonus = bonusPerDay[day] ? bonusPerDay[day].total : 0;
                const daySaque = saquePerDay[day] ? saquePerDay[day].total : 0;
                totalPontosMes += (parseInt(pointsValue) || 0) + (parseInt(dayBonus) || 0) - (parseInt(daySaque) || 0);
            }
            
            html += `<tr><td class="row-header">Total de pontos<br/> (${totalPontosMes} pts.)</td>`;
            for (let day = 1; day <= daysInMonth; day++) {
                const dayKey = `day${day}`;
                const pointsValue = data[monthKey][dayKey]?.pontos || 0;
                const dayBonus = bonusPerDay[day] ? bonusPerDay[day].total : 0;
                const totalDay = (parseInt(pointsValue) || 0) + (parseInt(dayBonus) || 0);
                const displayValue = totalDay > 0 ? totalDay : '';
                html += `<td class="points-row">${displayValue}</td>`;
            }
            html += '</tr>';

            // Linhas de atividades
            activities.forEach(activity => {
                html += `<tr><td class="row-header sub" style="background: ${activity.color}; border-width: 0px">${activity.name}</td>`;
                
                // Para Conjunto Diario e Pesquisas Bing PC, primeiro identificar todos os grupos no mês
                let groups = [];
                const groupDays = activity.id === 'conjuntodiario' ? 10 : activity.id === 'pesquisabingpc' ? 7 : activity.id === 'playgamepass' ? 7 : 0;
                
                // Para playconsole, identificar grupos de 5 dias dentro de cada semana
                let consoleGroups = [];
                if (activity.id === 'playconsole') {
                    // Verificar se há uma semana do mês anterior que continua neste mês
                    const prevMonth = currentMonth - 1;
                    const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                    const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                    const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                    const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                    
                    let markedDaysFromPrevMonth = [];
                    let countFromPrevMonth = 0;
                    
                    // Verificar os últimos dias do mês anterior para uma semana que continua
                    for (let d = prevMonthDays; d >= 1; d--) {
                        const dayOfWeek = getDayOfWeek(prevYear, prevMonthIndex, d);
                        if (dayOfWeek === 0) break; // Chegou no domingo, parar
                        
                        const dKey = `day${d}`;
                        const dValue = data[prevMonthKey]?.[dKey]?.[activity.id];
                        if (dValue && dValue !== '') {
                            markedDaysFromPrevMonth.unshift(d); // Adicionar no início
                            countFromPrevMonth++;
                        }
                    }
                    
                    // Processar cada semana do mês atual
                    for (let d = 1; d <= daysInMonth; d++) {
                        const dayOfWeek = getDayOfWeek(currentYear, currentMonth, d);
                        
                        // Se for segunda-feira ou primeiro dia do mês, começar uma nova semana
                        if (dayOfWeek === 1 || d === 1) {
                            // Encontrar o domingo dessa semana (ou último dia do mês)
                            let weekEnd = d;
                            for (let wd = d; wd <= daysInMonth; wd++) {
                                const wdDayOfWeek = getDayOfWeek(currentYear, currentMonth, wd);
                                weekEnd = wd;
                                if (wdDayOfWeek === 0) break; // Domingo
                            }
                            
                            // Contar dias marcados nesta semana
                            let markedDays = [];
                            for (let wd = d; wd <= weekEnd; wd++) {
                                const wdKey = `day${wd}`;
                                const wdValue = data[monthKey][wdKey]?.[activity.id];
                                if (wdValue && wdValue !== '') {
                                    markedDays.push(wd);
                                }
                            }
                            
                            // Se é a primeira semana do mês e há dias do mês anterior
                            if (d === 1 && countFromPrevMonth > 0) {
                                // Combinar com dias do mês anterior
                                const totalMarked = countFromPrevMonth + markedDays.length;
                                const remainingSlots = Math.max(0, 5 - countFromPrevMonth);
                                const daysWithBorder = markedDays.slice(0, remainingSlots);
                                
                                if (daysWithBorder.length > 0) {
                                    consoleGroups.push({
                                        start: daysWithBorder[0],
                                        end: daysWithBorder[daysWithBorder.length - 1],
                                        weekStart: d,
                                        weekEnd: weekEnd,
                                        daysWithBorder: daysWithBorder,
                                        continuesFromPrevMonth: true
                                    });
                                }
                            } else {
                                // Semana normal dentro do mês
                                if (markedDays.length > 0) {
                                    const daysWithBorder = markedDays.slice(0, 5);
                                    
                                    if (daysWithBorder.length > 0) {
                                        consoleGroups.push({
                                            start: daysWithBorder[0],
                                            end: daysWithBorder[daysWithBorder.length - 1],
                                            weekStart: d,
                                            weekEnd: weekEnd,
                                            daysWithBorder: daysWithBorder
                                        });
                                    }
                                }
                            }
                            
                            // Pular para o próximo dia após o domingo desta semana
                            d = weekEnd;
                        }
                    }
                }
                
                // Para playwindows, identificar grupos de 5 dias dentro de cada semana
                let windowsGroups = [];
                if (activity.id === 'playwindows') {
                    // Verificar se há uma semana do mês anterior que continua neste mês
                    const prevMonth = currentMonth - 1;
                    const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                    const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                    const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                    const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                    
                    let markedDaysFromPrevMonth = [];
                    let countFromPrevMonth = 0;
                    
                    // Verificar os últimos dias do mês anterior para uma semana que continua
                    for (let d = prevMonthDays; d >= 1; d--) {
                        const dayOfWeek = getDayOfWeek(prevYear, prevMonthIndex, d);
                        if (dayOfWeek === 0) break; // Chegou no domingo, parar
                        
                        const dKey = `day${d}`;
                        const dValue = data[prevMonthKey]?.[dKey]?.[activity.id];
                        if (dValue && dValue !== '') {
                            markedDaysFromPrevMonth.unshift(d); // Adicionar no início
                            countFromPrevMonth++;
                        }
                    }
                    
                    // Processar cada semana do mês atual
                    for (let d = 1; d <= daysInMonth; d++) {
                        const dayOfWeek = getDayOfWeek(currentYear, currentMonth, d);
                        
                        // Se for segunda-feira ou primeiro dia do mês, começar uma nova semana
                        if (dayOfWeek === 1 || d === 1) {
                            // Encontrar o domingo dessa semana (ou último dia do mês)
                            let weekEnd = d;
                            for (let wd = d; wd <= daysInMonth; wd++) {
                                const wdDayOfWeek = getDayOfWeek(currentYear, currentMonth, wd);
                                weekEnd = wd;
                                if (wdDayOfWeek === 0) break; // Domingo
                            }
                            
                            // Contar dias marcados nesta semana
                            let markedDays = [];
                            for (let wd = d; wd <= weekEnd; wd++) {
                                const wdKey = `day${wd}`;
                                const wdValue = data[monthKey][wdKey]?.[activity.id];
                                if (wdValue && wdValue !== '') {
                                    markedDays.push(wd);
                                }
                            }
                            
                            // Se é a primeira semana do mês e há dias do mês anterior
                            if (d === 1 && countFromPrevMonth > 0) {
                                // Combinar com dias do mês anterior
                                const totalMarked = countFromPrevMonth + markedDays.length;
                                const remainingSlots = Math.max(0, 5 - countFromPrevMonth);
                                const daysWithBorder = markedDays.slice(0, remainingSlots);
                                
                                if (daysWithBorder.length > 0) {
                                    windowsGroups.push({
                                        start: daysWithBorder[0],
                                        end: daysWithBorder[daysWithBorder.length - 1],
                                        weekStart: d,
                                        weekEnd: weekEnd,
                                        daysWithBorder: daysWithBorder,
                                        continuesFromPrevMonth: true
                                    });
                                }
                            } else {
                                // Semana normal dentro do mês
                                if (markedDays.length > 0) {
                                    const daysWithBorder = markedDays.slice(0, 5);
                                    
                                    if (daysWithBorder.length > 0) {
                                        windowsGroups.push({
                                            start: daysWithBorder[0],
                                            end: daysWithBorder[daysWithBorder.length - 1],
                                            weekStart: d,
                                            weekEnd: weekEnd,
                                            daysWithBorder: daysWithBorder
                                        });
                                    }
                                }
                            }
                            
                            // Pular para o próximo dia após o domingo desta semana
                            d = weekEnd;
                        }
                    }
                }
                
                // Para useappxbox, identificar grupos de ciclo (8 -> 16 -> 24 -> 32 -> 50)
                let xboxGroups = [];
                if (activity.id === 'useappxbox') {
                    // Ciclo de valores: 8, 16, 24, 32, 50
                    const cycleValues = [8, 16, 24, 32, 50];
                    
                    // Verificar se há um grupo do mês anterior que continua neste mês
                    const prevMonth = currentMonth - 1;
                    const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                    const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                    const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                    const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                    
                    let startingValueIndex = -1; // -1 significa começar do 8
                    
                    // Verificar o último dia do mês anterior
                    if (data[prevMonthKey]) {
                        const lastDayPrevMonthKey = `day${prevMonthDays}`;
                        const lastDayPrevMonthValue = data[prevMonthKey][lastDayPrevMonthKey]?.[activity.id];
                        
                        // Se o mês anterior terminou no meio de um ciclo, continuar
                        if (lastDayPrevMonthValue && lastDayPrevMonthValue !== 50) {
                            startingValueIndex = cycleValues.indexOf(lastDayPrevMonthValue);
                        }
                    }
                    
                    for (let d = 1; d <= daysInMonth; d++) {
                        const dKey = `day${d}`;
                        const dValue = data[monthKey][dKey]?.[activity.id];
                        
                        // Se é o primeiro dia e continua do mês anterior
                        if (d === 1 && startingValueIndex >= 0) {
                            const expectedNextIndex = startingValueIndex + 1;
                            if (expectedNextIndex < cycleValues.length && dValue === cycleValues[expectedNextIndex]) {
                                let groupStart = 1;
                                let groupEnd = 1;
                                let currentValueIndex = expectedNextIndex;
                                
                                // Procurar a sequência até o fim do ciclo ou um gap
                                for (let checkDay = 2; checkDay <= daysInMonth; checkDay++) {
                                    const checkKey = `day${checkDay}`;
                                    const checkValue = data[monthKey][checkKey]?.[activity.id];
                                    
                                    if (!checkValue || checkValue === '') {
                                        break;
                                    }
                                    
                                    const nextExpectedIndex = currentValueIndex + 1;
                                    if (nextExpectedIndex < cycleValues.length && checkValue === cycleValues[nextExpectedIndex]) {
                                        groupEnd = checkDay;
                                        currentValueIndex = nextExpectedIndex;
                                        
                                        if (checkValue === 50) {
                                            break;
                                        }
                                    } else {
                                        break;
                                    }
                                }
                                
                                xboxGroups.push({
                                    start: groupStart,
                                    end: groupEnd,
                                    continuesFromPrevMonth: true
                                });
                                
                                d = groupEnd;
                                continue;
                            }
                        }
                        
                        // Se encontrou um valor 8 (início do ciclo)
                        if (dValue === 8) {
                            let groupStart = d;
                            let groupEnd = d;
                            let currentValueIndex = 0; // Começa no 8
                            
                            // Procurar a sequência até o fim do ciclo ou um gap
                            for (let checkDay = d + 1; checkDay <= daysInMonth; checkDay++) {
                                const checkKey = `day${checkDay}`;
                                const checkValue = data[monthKey][checkKey]?.[activity.id];
                                
                                if (!checkValue || checkValue === '') {
                                    // Gap encontrado, encerrar grupo
                                    break;
                                }
                                
                                // Verificar se é o próximo valor esperado no ciclo
                                const expectedNextIndex = currentValueIndex + 1;
                                if (expectedNextIndex < cycleValues.length && checkValue === cycleValues[expectedNextIndex]) {
                                    groupEnd = checkDay;
                                    currentValueIndex = expectedNextIndex;
                                    
                                    // Se chegou no 50, encerrar grupo
                                    if (checkValue === 50) {
                                        break;
                                    }
                                } else {
                                    // Valor não esperado, encerrar grupo
                                    break;
                                }
                            }
                            
                            // Adicionar grupo se tiver mais de um dia ou se terminou no meio do ciclo
                            if (groupEnd > groupStart || data[monthKey][`day${groupEnd}`]?.[activity.id] !== 8) {
                                xboxGroups.push({
                                    start: groupStart,
                                    end: groupEnd
                                });
                            }
                            
                            // Pular para depois do grupo
                            d = groupEnd;
                        }
                    }
                }
                
                if (groupDays > 0) {
                    // Verificar se há um grupo do mês anterior que continua neste mês
                    const prevMonth = currentMonth - 1;
                    const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                    const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                    const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                    const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                    
                    // Verificar os últimos (groupDays-1) dias do mês anterior para grupos que continuam
                    for (let d = Math.max(1, prevMonthDays - (groupDays - 2)); d <= prevMonthDays; d++) {
                        const dKey = `day${d}`;
                        const dValue = data[prevMonthKey]?.[dKey]?.[activity.id];
                        
                        if (dValue && dValue !== '') {
                            // Verificar se é início de grupo
                            const prevDKey = `day${d - 1}`;
                            const prevDValue = data[prevMonthKey]?.[prevDKey]?.[activity.id];
                            
                            if (d === 1 || !prevDValue || prevDValue === '') {
                                // Este grupo pode continuar no mês atual
                                const groupStart = d;
                                const daysFromPrevMonth = prevMonthDays - d + 1;
                                const daysInCurrentMonth = groupDays - daysFromPrevMonth;
                                
                                if (daysInCurrentMonth > 0) {
                                    // Este grupo continua no mês atual
                                    groups.push({ 
                                        start: 1, 
                                        end: Math.min(daysInCurrentMonth, daysInMonth),
                                        crossMonth: true,
                                        prevMonthStart: groupStart
                                    });
                                }
                                break;
                            }
                        }
                    }
                    
                    let skipUntilDay = groups.length > 0 ? groups[0].end : 0;
                    
                    for (let d = 1; d <= daysInMonth; d++) {
                        if (d <= skipUntilDay) continue;
                        
                        const dKey = `day${d}`;
                        const dValue = data[monthKey][dKey]?.[activity.id];
                        
                        if (dValue && dValue !== '') {
                            // Este é o início de um grupo
                            const groupStart = d;
                            const maxPossibleEnd = d + (groupDays - 1);
                            let groupEnd = Math.min(maxPossibleEnd, daysInMonth);
                            
                            // Verificar se há um GAP dentro do mês atual
                            for (let checkDay = d; checkDay < groupEnd; checkDay++) {
                                const currentKey = `day${checkDay}`;
                                const currentValue = data[monthKey][currentKey]?.[activity.id];
                                const nextKey = `day${checkDay + 1}`;
                                const nextValue = data[monthKey][nextKey]?.[activity.id];
                                
                                if ((currentValue && currentValue !== '') && (!nextValue || nextValue === '')) {
                                    let hasValueAfterGap = false;
                                    for (let futureDay = checkDay + 2; futureDay <= groupEnd; futureDay++) {
                                        const futureKey = `day${futureDay}`;
                                        const futureValue = data[monthKey][futureKey]?.[activity.id];
                                        if (futureValue && futureValue !== '') {
                                            hasValueAfterGap = true;
                                            break;
                                        }
                                    }
                                    
                                    if (hasValueAfterGap) {
                                        groupEnd = checkDay;
                                        break;
                                    }
                                }
                            }
                            
                            const extendsToNextMonth = maxPossibleEnd > daysInMonth;
                            
                            groups.push({ 
                                start: groupStart, 
                                end: groupEnd,
                                extendsToNextMonth: extendsToNextMonth
                            });
                            skipUntilDay = groupEnd;
                        }
                    }
                }
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const dayKey = `day${day}`;
                    const value = data[monthKey][dayKey]?.[activity.id] || '';
                    const dayOfWeek = getDayOfWeek(currentYear, currentMonth, day);
                    
                    // Determinar se deve ter borda de grupo (para Conjunto Diario e Pesquisas Bing PC)
                    let borderClasses = [];
                    if (activity.id === 'conjuntodiario' || activity.id === 'pesquisabingpc') {
                        // Verificar se este dia está dentro de algum grupo
                        for (let group of groups) {
                            if (day >= group.start && day <= group.end) {
                                // Este dia faz parte de um grupo
                                borderClasses.push('group-border-top');
                                borderClasses.push('group-border-bottom');
                                borderClasses.push('group-background');
                                
                                // Borda esquerda no primeiro dia do grupo
                                if (day === group.start) {
                                    borderClasses.push('group-border-left');
                                } else {
                                    // Dentro do grupo, remover borda esquerda fina
                                    borderClasses.push('group-inside-left');
                                }
                                
                                // Borda direita no último dia do grupo
                                if (day === group.end) {
                                    borderClasses.push('group-border-right');
                                } else {
                                    // Dentro do grupo, remover borda direita fina
                                    borderClasses.push('group-inside-right');
                                }
                                break; // Só pode estar em um grupo
                            }
                        }
                    }
                    // Para playgamepass, verificar se é segunda-feira (início de semana) ou domingo (fim de semana)
                    else if (activity.id === 'playgamepass') {
                        const dayOfWeek = getDayOfWeek(currentYear, currentMonth, day);
                        
                        // Segunda-feira (1) = início da semana
                        if (dayOfWeek === 1) {
                            borderClasses.push('group-border-left');
                            borderClasses.push('group-border-top');
                            borderClasses.push('group-border-bottom');
                        }
                        // Domingo (0) = fim da semana
                        else if (dayOfWeek === 0) {
                            borderClasses.push('group-border-right');
                            borderClasses.push('group-border-top');
                            borderClasses.push('group-border-bottom');
                        }
                        // Terça a Sábado (2-6) = meio da semana
                        else {
                            borderClasses.push('group-border-top');
                            borderClasses.push('group-border-bottom');
                            borderClasses.push('group-inside-left');
                            borderClasses.push('group-inside-right');
                        }
                    }
                    // Para playconsole, verificar se está em um grupo de 5 dias
                    else if (activity.id === 'playconsole') {
                        // Verificar se este dia está dentro de algum grupo
                        for (let group of consoleGroups) {
                            // Verificar se este dia está nos primeiros 5 dias marcados
                            if (group.daysWithBorder.includes(day)) {
                                // Este dia faz parte do grupo de 5 dias com borda
                                borderClasses.push('group-border-top');
                                borderClasses.push('group-border-bottom');
                                borderClasses.push('group-background');
                                
                                // Borda esquerda no primeiro dia do grupo
                                if (day === group.start) {
                                    borderClasses.push('group-border-left');
                                } else {
                                    // Dentro do grupo, remover borda esquerda fina
                                    borderClasses.push('group-inside-left');
                                }
                                
                                // Borda direita no último dia do grupo
                                if (day === group.end) {
                                    borderClasses.push('group-border-right');
                                } else {
                                    // Dentro do grupo, remover borda direita fina
                                    borderClasses.push('group-inside-right');
                                }
                                break;
                            } 
                            // Verificar se é um dia vazio ENTRE dias marcados (gap)
                            else if (day > group.start && day < group.end && !group.daysWithBorder.includes(day)) {
                                // Este é um gap - aplicar bordas para fechar
                                borderClasses.push('group-border-top');
                                borderClasses.push('group-border-bottom');
                                borderClasses.push('group-inside-left');
                                borderClasses.push('group-inside-right');
                                break;
                            }
                        }
                    }
                    // Para playwindows, verificar se está em um grupo de 5 dias
                    else if (activity.id === 'playwindows') {
                        // Verificar se este dia está dentro de algum grupo
                        for (let group of windowsGroups) {
                            // Verificar se este dia está nos primeiros 5 dias marcados
                            if (group.daysWithBorder.includes(day)) {
                                // Este dia faz parte do grupo de 5 dias com borda
                                borderClasses.push('group-border-top');
                                borderClasses.push('group-border-bottom');
                                borderClasses.push('group-background');
                                
                                // Borda esquerda no primeiro dia do grupo
                                if (day === group.start) {
                                    borderClasses.push('group-border-left');
                                } else {
                                    // Dentro do grupo, remover borda esquerda fina
                                    borderClasses.push('group-inside-left');
                                }
                                
                                // Borda direita no último dia do grupo
                                if (day === group.end) {
                                    borderClasses.push('group-border-right');
                                } else {
                                    // Dentro do grupo, remover borda direita fina
                                    borderClasses.push('group-inside-right');
                                }
                                break;
                            } 
                            // Verificar se é um dia vazio ENTRE dias marcados (gap)
                            else if (day > group.start && day < group.end && !group.daysWithBorder.includes(day)) {
                                // Este é um gap - aplicar bordas para fechar
                                borderClasses.push('group-border-top');
                                borderClasses.push('group-border-bottom');
                                borderClasses.push('group-inside-left');
                                borderClasses.push('group-inside-right');
                                break;
                            }
                        }
                    }
                    // Para useappxbox, verificar se está em um grupo de ciclo
                    else if (activity.id === 'useappxbox') {
                        // Verificar se este dia está dentro de algum grupo
                        for (let group of xboxGroups) {
                            if (day >= group.start && day <= group.end) {
                                // Este dia faz parte de um grupo
                                borderClasses.push('group-border-top');
                                borderClasses.push('group-border-bottom');
                                borderClasses.push('group-background');
                                
                                // Borda esquerda no primeiro dia do grupo
                                if (day === group.start) {
                                    borderClasses.push('group-border-left');
                                } else {
                                    // Dentro do grupo, remover borda esquerda fina
                                    borderClasses.push('group-inside-left');
                                }
                                
                                // Borda direita no último dia do grupo
                                if (day === group.end) {
                                    borderClasses.push('group-border-right');
                                } else {
                                    // Dentro do grupo, remover borda direita fina
                                    borderClasses.push('group-inside-right');
                                }
                                break;
                            }
                        }
                    }
                    const borderClass = borderClasses.join(' ');
                    
                    // Se for o Conjunto Diario, usar select
                    if (activity.id === 'conjuntodiario') {
                        const emptyBgClass = (!value && !borderClass.includes('group-background')) ? 'group-empty-background' : '';
                        const finalClass = `${borderClass} ${emptyBgClass}`.trim();
                        html += `<td class="editable ${finalClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="10" ${value === 10 ? 'selected' : ''}>10</option>`;
                        html += `<option value="20" ${value === 20 ? 'selected' : ''}>20</option>`;
                        html += `<option value="30" ${value === 30 ? 'selected' : ''}>30</option>`;
                        html += `</select></td>`;
                    }
                    // Se for Mais Atividade, usar select com regras especiais
                    else if (activity.id === 'maisatividade') {
                        const hasValue = value !== '' && value !== null && value !== undefined;
                        const bgClass = hasValue ? 'group-background' : 'group-empty-background';
                        
                        if (dayOfWeek === 0) {
                            // Domingo - desabilitado
                            html += `<td class="editable" style="background: #cccccc;">`;
                            html += `<select disabled>`;
                            html += `<option value="">-</option>`;
                            html += `</select></td>`;
                        } else if (dayOfWeek === 6) {
                            // Sábado - apenas opção 5
                            html += `<td class="editable ${bgClass}">`;
                            html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                            html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                            html += `<option value="5" ${value === 5 ? 'selected' : ''}>5</option>`;
                            html += `</select></td>`;
                        } else {
                            // Dias de semana - todas as opções
                            html += `<td class="editable ${bgClass}">`;
                            html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                            html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                            html += `<option value="5" ${value === 5 ? 'selected' : ''}>5</option>`;
                            html += `<option value="10" ${value === 10 ? 'selected' : ''}>10</option>`;
                            html += `<option value="15" ${value === 15 ? 'selected' : ''}>15</option>`;
                            html += `<option value="20" ${value === 20 ? 'selected' : ''}>20</option>`;
                            html += `<option value="25" ${value === 25 ? 'selected' : ''}>25</option>`;
                            html += `</select></td>`;
                        }
                    }
                    // Se for Pesquisas Bing PC, validar múltiplos de 3 (máximo 150)
                    else if (activity.id === 'pesquisabingpc') {
                        const emptyBgClass = (!value && !borderClass.includes('group-background')) ? 'group-empty-background' : '';
                        const finalClass = `${borderClass} ${emptyBgClass}`.trim();
                        html += `<td class="editable ${finalClass}" 
                                 onclick="editCell('${monthKey}', '${dayKey}', '${activity.id}', this)">
                                 <input type="number" 
                                        value="${value}" 
                                        min="0"
                                        max="150"
                                        step="3"
                                        onchange="validateMultipleOf3('${monthKey}', '${dayKey}', '${activity.id}', this, 150)"
                                        onblur="calculateDayTotal('${monthKey}', '${dayKey}')">
                                 </td>`;
                    }
                    // Se for Diaria do App Bing, usar select com opções baseadas no ciclo
                    else if (activity.id === 'diariabing') {
                        // Determinar qual opção está disponível baseado no dia anterior
                        let availableOption = 5; // Padrão: começa com 5
                        
                        if (day > 1) {
                            // Verificar o valor do dia anterior
                            const prevDayKey = `day${day - 1}`;
                            const prevValue = data[monthKey][prevDayKey]?.diariabing;
                            
                            if (prevValue) {
                                // Definir próxima opção baseada no ciclo
                                if (prevValue === 5) {
                                    // Verificar se é o primeiro ou segundo 5
                                    let twoDaysAgoValue = null;
                                    if (day > 2) {
                                        const twoDaysAgoKey = `day${day - 2}`;
                                        twoDaysAgoValue = data[monthKey][twoDaysAgoKey]?.diariabing;
                                    } else if (day === 2) {
                                        // Dia 2 do mês, verificar último dia do mês anterior
                                        const prevMonth = currentMonth - 1;
                                        const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                                        const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                                        const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                                        const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                                        const lastDayPrevMonthKey = `day${prevMonthDays}`;
                                        twoDaysAgoValue = data[prevMonthKey]?.[lastDayPrevMonthKey]?.diariabing;
                                    }
                                    availableOption = (twoDaysAgoValue === 5) ? 10 : 5;
                                } else if (prevValue === 10) {
                                    // Verificar se é o primeiro ou segundo 10
                                    let twoDaysAgoValue = null;
                                    if (day > 2) {
                                        const twoDaysAgoKey = `day${day - 2}`;
                                        twoDaysAgoValue = data[monthKey][twoDaysAgoKey]?.diariabing;
                                    } else if (day === 2) {
                                        // Dia 2 do mês, verificar último dia do mês anterior
                                        const prevMonth = currentMonth - 1;
                                        const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                                        const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                                        const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                                        const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                                        const lastDayPrevMonthKey = `day${prevMonthDays}`;
                                        twoDaysAgoValue = data[prevMonthKey]?.[lastDayPrevMonthKey]?.diariabing;
                                    }
                                    availableOption = (twoDaysAgoValue === 10) ? 15 : 10;
                                } else if (prevValue === 15) {
                                    // Verificar se é o primeiro ou segundo 15
                                    let twoDaysAgoValue = null;
                                    if (day > 2) {
                                        const twoDaysAgoKey = `day${day - 2}`;
                                        twoDaysAgoValue = data[monthKey][twoDaysAgoKey]?.diariabing;
                                    } else if (day === 2) {
                                        // Dia 2 do mês, verificar último dia do mês anterior
                                        const prevMonth = currentMonth - 1;
                                        const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                                        const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                                        const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                                        const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                                        const lastDayPrevMonthKey = `day${prevMonthDays}`;
                                        twoDaysAgoValue = data[prevMonthKey]?.[lastDayPrevMonthKey]?.diariabing;
                                    }
                                    availableOption = (twoDaysAgoValue === 15) ? 50 : 15;
                                } else if (prevValue === 50) {
                                    availableOption = 5; // Recomeça o ciclo
                                }
                            } else {
                                // Dia anterior vazio, começar com 5
                                availableOption = 5;
                            }
                        } else {
                            // Primeiro dia do mês, verificar último dia do mês anterior
                            const prevMonth = currentMonth - 1;
                            const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                            const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                            const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                            const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                            const lastDayPrevMonthKey = `day${prevMonthDays}`;
                            const lastDayPrevMonthValue = data[prevMonthKey]?.[lastDayPrevMonthKey]?.diariabing;
                            
                            if (lastDayPrevMonthValue) {
                                if (lastDayPrevMonthValue === 5) {
                                    const twoDaysAgoKey = `day${prevMonthDays - 1}`;
                                    const twoDaysAgoValue = data[prevMonthKey]?.[twoDaysAgoKey]?.diariabing;
                                    availableOption = (twoDaysAgoValue === 5) ? 10 : 5;
                                } else if (lastDayPrevMonthValue === 10) {
                                    const twoDaysAgoKey = `day${prevMonthDays - 1}`;
                                    const twoDaysAgoValue = data[prevMonthKey]?.[twoDaysAgoKey]?.diariabing;
                                    availableOption = (twoDaysAgoValue === 10) ? 15 : 10;
                                } else if (lastDayPrevMonthValue === 15) {
                                    const twoDaysAgoKey = `day${prevMonthDays - 1}`;
                                    const twoDaysAgoValue = data[prevMonthKey]?.[twoDaysAgoKey]?.diariabing;
                                    availableOption = (twoDaysAgoValue === 15) ? 50 : 15;
                                } else if (lastDayPrevMonthValue === 50) {
                                    availableOption = 5;
                                }
                            }
                        }
                        
                        const hasValue = value !== '' && value !== null && value !== undefined;
                        const bgClass = hasValue ? 'bing-app-filled' : 'bing-app-empty';
                        
                        html += `<td class="editable ${bgClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="${availableOption}" ${value === availableOption ? 'selected' : ''}>${availableOption}</option>`;
                        html += `</select></td>`;
                    }
                    // Se for Noticias do App Bing, validar múltiplos de 3 (máximo 30)
                    else if (activity.id === 'noticiasbing') {
                        const hasValue = value !== '' && value !== null && value !== undefined;
                        const bgClass = hasValue ? 'bing-app-filled' : 'bing-app-empty';
                        
                        html += `<td class="editable ${bgClass}" 
                                 onclick="editCell('${monthKey}', '${dayKey}', '${activity.id}', this)">
                                 <input type="number" 
                                        value="${value}" 
                                        min="0"
                                        max="30"
                                        step="3"
                                        onchange="validateMultipleOf3('${monthKey}', '${dayKey}', '${activity.id}', this, 30)"
                                        onblur="calculateDayTotal('${monthKey}', '${dayKey}')">
                                 </td>`;
                    }
                    // Se for Jogar Jewels no Celular, usar select com opções 0 ou 10
                    else if (activity.id === 'playjewels') {
                        const greenBgClass = value ? 'green-app-filled' : 'green-app-empty';
                        html += `<td class="editable ${greenBgClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="10" ${value === 10 ? 'selected' : ''}>10</option>`;
                        html += `</select></td>`;
                    }
                    // Se for Use o App Xbox no Celular, usar select com opções baseadas no ciclo
                    else if (activity.id === 'useappxbox') {
                        // Determinar qual opção está disponível baseado no dia anterior
                        // Ciclo: 8 -> 16 -> 24 -> 32 -> 50 -> (volta ao 8)
                        let availableOption = 8; // Padrão: começa com 8
                        
                        if (day > 1) {
                            // Verificar o valor do dia anterior
                            const prevDayKey = `day${day - 1}`;
                            const prevValue = data[monthKey][prevDayKey]?.useappxbox;
                            
                            if (prevValue) {
                                // Definir próxima opção baseada no ciclo
                                if (prevValue === 8) {
                                    availableOption = 16;
                                } else if (prevValue === 16) {
                                    availableOption = 24;
                                } else if (prevValue === 24) {
                                    availableOption = 32;
                                } else if (prevValue === 32) {
                                    availableOption = 50;
                                } else if (prevValue === 50) {
                                    availableOption = 8; // Recomeça o ciclo
                                }
                            } else {
                                // Dia anterior vazio, começar com 8
                                availableOption = 8;
                            }
                        } else {
                            // Primeiro dia do mês, verificar último dia do mês anterior
                            const prevMonth = currentMonth - 1;
                            const prevYear = prevMonth < 0 ? currentYear - 1 : currentYear;
                            const prevMonthIndex = prevMonth < 0 ? 11 : prevMonth;
                            const prevMonthKey = `${prevYear}-${prevMonthIndex}`;
                            const prevMonthDays = getDaysInMonth(prevYear, prevMonthIndex);
                            const lastDayPrevMonthKey = `day${prevMonthDays}`;
                            const lastDayPrevMonthValue = data[prevMonthKey]?.[lastDayPrevMonthKey]?.useappxbox;
                            
                            if (lastDayPrevMonthValue) {
                                if (lastDayPrevMonthValue === 8) {
                                    availableOption = 16;
                                } else if (lastDayPrevMonthValue === 16) {
                                    availableOption = 24;
                                } else if (lastDayPrevMonthValue === 24) {
                                    availableOption = 32;
                                } else if (lastDayPrevMonthValue === 32) {
                                    availableOption = 50;
                                } else if (lastDayPrevMonthValue === 50) {
                                    availableOption = 8;
                                }
                            }
                        }
                        
                        const emptyBgClass = (!value && !borderClass.includes('group-background')) ? 'group-empty-background' : '';
                        const greenBgClass = value ? 'green-app-filled' : 'green-app-empty';
                        const finalClass = `${borderClass} ${emptyBgClass} ${greenBgClass}`.trim();
                        html += `<td class="editable ${finalClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="${availableOption}" ${value === availableOption ? 'selected' : ''}>${availableOption}</option>`;
                        html += `</select></td>`;
                    }
                    // Se for Jogar um jogo pelo Gamepass, usar select com opções 0 ou 20
                    else if (activity.id === 'playgamepass') {
                        const gameBgClass = value ? 'game-app-filled' : 'game-app-empty';
                        const finalClass = `${borderClass} ${gameBgClass}`.trim();
                        html += `<td class="editable ${finalClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="20" ${value === 20 ? 'selected' : ''}>20</option>`;
                        html += `</select></td>`;
                    }
                    // Se for Jogar um jogo no Console, usar select com opções 0 ou 20
                    else if (activity.id === 'playconsole') {
                        const emptyBgClass = (!value && !borderClass.includes('group-background')) ? 'group-empty-background' : '';
                        const gameBgClass = value ? 'game-app-filled' : 'game-app-empty';
                        const finalClass = `${borderClass} ${emptyBgClass} ${gameBgClass}`.trim();
                        html += `<td class="editable ${finalClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="20" ${value === 20 ? 'selected' : ''}>20</option>`;
                        html += `</select></td>`;
                    }
                    // Se for Jogar um jogo no Windows, usar select com opções 0 ou 20
                    else if (activity.id === 'playwindows') {
                        const emptyBgClass = (!value && !borderClass.includes('group-background')) ? 'group-empty-background' : '';
                        const gameBgClass = value ? 'game-app-filled' : 'game-app-empty';
                        const finalClass = `${borderClass} ${emptyBgClass} ${gameBgClass}`.trim();
                        html += `<td class="editable ${finalClass}">`;
                        html += `<select onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)">`;
                        html += `<option value="" ${value === '' ? 'selected' : ''}>-</option>`;
                        html += `<option value="20" ${value === 20 ? 'selected' : ''}>20</option>`;
                        html += `</select></td>`;
                    }
                    else {
                        html += `<td class="editable ${borderClass}" 
                                 onclick="editCell('${monthKey}', '${dayKey}', '${activity.id}', this)">
                                 <input type="number" 
                                        value="${value}" 
                                        onchange="updateCell('${monthKey}', '${dayKey}', '${activity.id}', this.value)"
                                        onblur="calculateDayTotal('${monthKey}', '${dayKey}')">
                                 </td>`;
                    }
                }
                html += '</tr>';
            });

            // Linha 1: Título "Pontuação Bonus" (aparece na coluna onde há bônus)
            html += '<tr style="height: 40px;">';
            html += '<td class="row-header" style="background: #F2F2F2; border: none; height: 40px;"></td>';
            for (let day = 1; day <= daysInMonth; day++) {
                const hasBonus = bonusPerDay[day];
                const bonusText = hasBonus ? 'Pontuação Bonus' : '';
                const bonusStyle = hasBonus 
                    ? 'background: #000000; color: white; border: 3px solid #000000; border-bottom: none; height: 40px; text-align: center; font-weight: bold; font-size: 10px;'
                    : 'background: #F2F2F2; border: none; height: 40px; text-align: center; font-weight: bold; font-size: 10px;';
                html += `<td style="${bonusStyle}">${bonusText}</td>`;
            }
            html += '</tr>';
            
            // Linha 2: Valores de bônus (+100 no 7º dia de cada grupo)
            html += '<tr style="height: 40px;">';
            html += '<td class="row-header" style="background: #F2F2F2; border: none; height: 40px;"></td>';
            for (let day = 1; day <= daysInMonth; day++) {
                const bonus = bonusPerDay[day];
                const bonusDisplay = bonus ? `${bonus.total}` : '';
                const valueStyle = bonus
                    ? 'background: #F2F2F2; border: 3px solid #000000; border-top: none; height: 40px; text-align: center; font-weight: bold; color: #00B050; cursor: pointer;'
                    : 'background: #F2F2F2; border: none; height: 40px; text-align: center; font-weight: bold; color: #00B050;';
                
                if (bonus) {
                    // Construir tooltip com todos os bônus do dia
                    let tooltipText = 'Bonus adicionado a esse dia:<br>';
                    bonus.items.forEach(item => {
                        tooltipText += `+${item.value} → ${item.name}<br>`;
                    });
                    
                    html += `<td style="${valueStyle}">
                        <div class="bonus-cell-wrapper">
                            ${bonusDisplay}
                            <span class="bonus-tooltip">${tooltipText}</span>
                        </div>
                    </td>`;
                } else {
                    html += `<td style="${valueStyle}">${bonusDisplay}</td>`;
                }
            }
            html += '</tr>';

            // === LINHAS DE SAQUE ===
            html += '<tr style="height: 40px;">';
            html += '<td class="row-header" style="background: #F2F2F2; border: none; height: 40px;"></td>';
            for (let day = 1; day <= daysInMonth; day++) {
                const hasSaque = saquePerDay[day];
                const saqueText = hasSaque ? 'Saque' : '';
                const saqueStyle = hasSaque 
                    ? 'background: #C00000; color: white; border: 3px solid #000000; border-bottom: none; height: 40px; text-align: center; font-weight: bold; font-size: 10px;'
                    : 'background: #F2F2F2; border: none; height: 40px; text-align: center; font-weight: bold; font-size: 10px;';
                html += `<td style="${saqueStyle}">${saqueText}</td>`;
            }
            html += '</tr>';
            
            html += '<tr style="height: 40px;">';
            html += '<td class="row-header" style="background: #F2F2F2; border: none; height: 40px;"></td>';
            for (let day = 1; day <= daysInMonth; day++) {
                const saque = saquePerDay[day];
                const saqueDisplay = saque ? `${saque.total}` : '';
                const valueStyle = saque
                    ? 'background: #F2F2F2; border: 3px solid #000000; border-top: none; height: 40px; text-align: center; font-weight: bold; color: #C00000; cursor: pointer;'
                    : 'background: #F2F2F2; border: none; height: 40px; text-align: center; font-weight: bold; color: #C00000;';
                
                if (saque) {
                    let tooltipText = 'Saques realizados neste dia:<br>';
                    saque.items.forEach(item => {
                        tooltipText += `-${item.value} → ${item.name}<br>`;
                    });
                    
                    html += `<td style="${valueStyle}">
                        <div class="bonus-cell-wrapper">
                            ${saqueDisplay}
                            <span class="bonus-tooltip">${tooltipText}</span>
                        </div>
                    </td>`;
                } else {
                    html += `<td style="${valueStyle}">${saqueDisplay}</td>`;
                }
            }
            html += '</tr>';

            html += '</tbody></table>';
            document.getElementById('tableContainer').innerHTML = html;
        }

        function editCell(monthKey, dayKey, activityId, cell) {
            const input = cell.querySelector('input');
            if (input) {
                input.focus();
                input.select();
            }
        }

        function updateCell(monthKey, dayKey, activityId, value) {
            if (!data[monthKey]) data[monthKey] = {};
            if (!data[monthKey][dayKey]) data[monthKey][dayKey] = {};
            
            data[monthKey][dayKey][activityId] = value ? parseInt(value) : '';
            calculateDayTotal(monthKey, dayKey);
            saveData();
        }

        function validateMultipleOf3(monthKey, dayKey, activityId, input, maxValue = 90) {
            let value = parseInt(input.value);
            
            // Se o campo estiver vazio, permitir
            if (!input.value || input.value === '') {
                updateCell(monthKey, dayKey, activityId, '');
                return;
            }
            
            // Validar se é um número
            if (isNaN(value)) {
                alert('⚠️ Por favor, digite um número válido!');
                input.value = '';
                return;
            }
            
            // Validar mínimo e máximo
            if (value < 0) {
                alert('⚠️ O valor mínimo é 0!');
                input.value = '';
                return;
            }
            
            if (value > maxValue) {
                alert(`⚠️ O valor máximo é ${maxValue}!`);
                input.value = maxValue;
                value = maxValue;
            }
            
            // Validar se é múltiplo de 3
            if (value % 3 !== 0) {
                // Arredondar para o múltiplo de 3 mais próximo
                const roundedValue = Math.round(value / 3) * 3;
                alert(`⚠️ O valor deve ser múltiplo de 3. Ajustando para ${roundedValue}.`);
                input.value = roundedValue;
                value = roundedValue;
            }
            
            // Garantir que o valor final está dentro dos limites
            if (value > maxValue) value = maxValue;
            if (value < 0) value = 0;
            
            input.value = value;
            updateCell(monthKey, dayKey, activityId, value);
        }

        function calculateDayTotal(monthKey, dayKey) {
            if (!data[monthKey] || !data[monthKey][dayKey]) return;
            
            let total = 0;
            activities.forEach(activity => {
                const value = data[monthKey][dayKey][activity.id];
                if (value && !isNaN(value)) {
                    total += parseInt(value);
                }
            });
            
            const bonus = data[monthKey][dayKey].bonus;
            if (bonus && !isNaN(bonus)) {
                total += parseInt(bonus);
            }
            
            data[monthKey][dayKey].pontos = total;
            generateTable();
        }

        function editBonus(monthKey, dayKey) {
            const bonus = prompt('Digite o valor do bônus:', data[monthKey]?.[dayKey]?.bonus || '');
            const bonusLabel = prompt('Digite a descrição do bônus (ex: Gift Card, Quebra Bing):', 
                                     data[monthKey]?.[dayKey]?.bonusLabel || '');
            
            if (bonus !== null) {
                if (!data[monthKey]) data[monthKey] = {};
                if (!data[monthKey][dayKey]) data[monthKey][dayKey] = {};
                
                data[monthKey][dayKey].bonus = bonus ? parseInt(bonus) : '';
                data[monthKey][dayKey].bonusLabel = bonusLabel || '';
                calculateDayTotal(monthKey, dayKey);
                saveData();
            }
        }

        function previousMonth() {
            currentMonth--;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
            updateMonthDisplay();
            generateTable();
        }

        function nextMonth() {
            currentMonth++;
            if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            updateMonthDisplay();
            generateTable();
        }

        // Funções para gerenciar pontuações extras
        function openAddBonusModal() {
            document.getElementById('addBonusModal').style.display = 'block';
            // Limpar campos
            document.getElementById('bonusTitle').value = '';
            document.getElementById('bonusPoints').value = '';
            document.getElementById('bonusDate').value = '';
        }

        function closeAddBonusModal() {
            document.getElementById('addBonusModal').style.display = 'none';
        }

        function addExtraBonus() {
            const title = document.getElementById('bonusTitle').value.trim();
            const points = parseInt(document.getElementById('bonusPoints').value);
            const day = parseInt(document.getElementById('bonusDate').value);
            const daysInMonth = getDaysInMonth(currentYear, currentMonth);

            // Validações
            if (!title) {
                alert('Por favor, insira um título para a pontuação.');
                return;
            }
            if (!points || points <= 0) {
                alert('Por favor, insira uma quantidade válida de pontos.');
                return;
            }
            if (!day || day < 1 || day > daysInMonth) {
                alert(`Por favor, insira um dia válido entre 1 e ${daysInMonth}.`);
                return;
            }

            // Adicionar ao data com estrutura de bônus extras
            const monthKey = `${currentYear}-${currentMonth}`;
            if (!data[monthKey]) {
                data[monthKey] = {};
            }
            
            // Inicializar estrutura de bônus extras se não existir
            if (!data[monthKey].extraBonuses) {
                data[monthKey].extraBonuses = {};
            }
            
            const dayKey = `day${day}`;
            if (!data[monthKey].extraBonuses[dayKey]) {
                data[monthKey].extraBonuses[dayKey] = [];
            }
            
            // Adicionar o bônus extra
            data[monthKey].extraBonuses[dayKey].push({
                title: title,
                points: points
            });

            // Salvar e regenerar tabela
            saveData();
            generateTable();
            closeAddBonusModal();
            
            alert(`✅ Pontuação "${title}" de ${points} pontos adicionada ao dia ${day}!`);
        }

        // Funções para gerenciar saques
        function openSaqueModal() {
            document.getElementById('saqueModal').style.display = 'block';
            document.getElementById('saqueTitle').value = '';
            document.getElementById('saquePoints').value = '';
            document.getElementById('saqueDate').value = '';
        }

        function closeSaqueModal() {
            document.getElementById('saqueModal').style.display = 'none';
        }

        function addSaque() {
            const title = document.getElementById('saqueTitle').value.trim();
            const points = parseInt(document.getElementById('saquePoints').value);
            const day = parseInt(document.getElementById('saqueDate').value);
            const daysInMonth = getDaysInMonth(currentYear, currentMonth);

            if (!title) {
                alert('Por favor, insira um título para o saque.');
                return;
            }
            if (!points || points <= 0) {
                alert('Por favor, insira uma quantidade válida de pontos.');
                return;
            }
            if (!day || day < 1 || day > daysInMonth) {
                alert(`Por favor, insira um dia válido entre 1 e ${daysInMonth}.`);
                return;
            }

            const monthKey = `${currentYear}-${currentMonth}`;
            if (!data[monthKey]) {
                data[monthKey] = {};
            }
            
            if (!data[monthKey].saques) {
                data[monthKey].saques = {};
            }
            
            const dayKey = `day${day}`;
            if (!data[monthKey].saques[dayKey]) {
                data[monthKey].saques[dayKey] = [];
            }
            
            data[monthKey].saques[dayKey].push({
                title: title,
                points: points
            });

            saveData();
            generateTable();
            closeSaqueModal();
            
            alert(`✅ Saque "${title}" de ${points} pontos registrado no dia ${day}!`);
        }

        // Fechar modal ao clicar fora dele
        window.onclick = function(event) {
            const modalBonus = document.getElementById('addBonusModal');
            const modalSaque = document.getElementById('saqueModal');
            if (event.target == modalBonus) {
                closeAddBonusModal();
            }
            if (event.target == modalSaque) {
                closeSaqueModal();
            }
        }

        function saveData() {
            localStorage.setItem('msRewardsData', JSON.stringify(data));
            // alert('✅ Dados salvos com sucesso!');
        }

        function loadData() {
            const saved = localStorage.getItem('msRewardsData');
            if (saved) {
                data = JSON.parse(saved);
            }
        }

        function clearMonth() {
            if (confirm('Tem certeza que deseja limpar todos os dados deste mês?')) {
                const monthKey = `${currentYear}-${currentMonth}`;
                data[monthKey] = {};
                generateTable();
                saveData();
            }
        }

        function exportData() {
            // Exporta o JSON completo do localStorage (data)
            const jsonData = localStorage.getItem('msRewardsData') || JSON.stringify(data);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `MS_Rewards_Export_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            // Verificar se é um arquivo JSON
            if (!file.name.endsWith('.json')) {
                alert('⚠️ Por favor, selecione um arquivo JSON válido!');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validar se o JSON tem a estrutura esperada
                    if (typeof importedData !== 'object' || importedData === null) {
                        throw new Error('Estrutura de dados inválida');
                    }

                    // Perguntar ao usuário se deseja substituir ou mesclar os dados
                    data = importedData;
                    
                    // Salvar no localStorage e atualizar a tabela
                    localStorage.setItem('msRewardsData', JSON.stringify(data));
                    generateTable();
                    
                    alert('✅ Dados importados com sucesso!');
                } catch (error) {
                    alert('❌ Erro ao importar arquivo: ' + error.message + '\n\nVerifique se o arquivo é um JSON válido exportado desta aplicação.');
                }
            };

            reader.onerror = function() {
                alert('❌ Erro ao ler o arquivo. Por favor, tente novamente.');
            };

            reader.readAsText(file);
            
            // Limpar o input para permitir importar o mesmo arquivo novamente
            event.target.value = '';
        }

        // Inicializar ao carregar a página
        window.onload = init;

        // Auto-save a cada 30 segundos
        setInterval(() => {
            saveData();
        }, 30000);
    </script>
</body>
</html>
